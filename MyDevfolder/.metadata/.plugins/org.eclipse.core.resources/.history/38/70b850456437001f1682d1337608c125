import java.awt.Desktop;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.lang.reflect.Type;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpHeaders;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.Year;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.text.StringEscapeUtils;
import org.json.JSONObject;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import javafx.animation.KeyFrame;
import javafx.animation.PauseTransition;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonType;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.Slider;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.control.TextInputDialog;
import javafx.scene.control.ToggleGroup;
import javafx.scene.image.Image;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.web.WebEngine;
import javafx.scene.web.WebView;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.util.Duration;

public class EnergyAdvisorApp extends Application {

    // アプリケーションのバージョン
    private String ver = "1.0";

    // APIトークン
    private static String apiToken = "";

    // APIのURL
    private static String apiUrl = "Gemini";

    // ストリーミング処理の有効/無効
    private static String UseDiv = "False";

    // メインAPIのURL
    private static String MainAPIurl = "https://webapi-8trs.onrender.com/chat";

    // ユーザーID
    Random random = new Random();
    int user_id = 1000 + random.nextInt(9000);

    // Beta版の有効/無効フラグ
    private boolean isBetaEnabled = false;
    
   // 現在の年を表すstatic変数
    private static int currentYear = Year.now().getValue();

    // UIコンポーネント
    private Label betaStatusLabel;
    private Button analyzeButton;
    private Slider panelScale;
    private Slider sunshineScale;
    private TextField generationField;
    private ComboBox<String> locationComboBox;
    private Slider angleScale;
    private TextField installationTimeField;
    private TextField systemCapacityField;
    private TextArea purposeField;
    private ProgressBar progressBar;
    private WebView webView;
    private WebEngine webEngine;

    // 前回のクリック時間
    private static long lastClickTime = 0;

    @Override
    public void start(Stage primaryStage) {
        // 設定の読み込み
        loadSettings();

        // 自動更新の確認 (5秒間隔)
        Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(5), ae -> userChoiceToUpdate()));
        timeline.play();

        // メイン画面のセットアップ
        primaryStage.setTitle("エネルギー効率改善アドバイザー");
        primaryStage.getIcons().add(new Image(EnergyAdvisorApp.class.getResourceAsStream("/icon.png")));

        // メニューバーの作成
        MenuBar menuBar = createMenuBar(primaryStage);

        // メインコンテンツ領域の作成
        BorderPane rootPane = new BorderPane();
        rootPane.setTop(menuBar);
        rootPane.setCenter(createMainContentArea());

        // シーンの作成と表示
        Scene scene = new Scene(rootPane, 910, 700);
        scene.getStylesheets().add(getClass().getResource("style.css").toExternalForm());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    // メニューバーを作成するメソッド
    private MenuBar createMenuBar(Stage primaryStage) {
        MenuBar menuBar = new MenuBar();

        // 表示メニュー
        Menu viewMenu = new Menu("表示");
        RadioMenuItem normalItem = new RadioMenuItem("通常表示");
        normalItem.setOnAction(e -> primaryStage.setFullScreen(false));
        RadioMenuItem fullscreenItem = new RadioMenuItem("フルスクリーン表示");
        fullscreenItem.setOnAction(e -> primaryStage.setFullScreen(true));

        ToggleGroup viewGroup = new ToggleGroup();
        normalItem.setToggleGroup(viewGroup);
        fullscreenItem.setToggleGroup(viewGroup);
        viewMenu.getItems().addAll(normalItem, fullscreenItem);

        // 設定メニュー
        Menu settingsMenu = new Menu("設定");
        MenuItem aimodel = new MenuItem("AIモデルの切り替え");
        aimodel.setOnAction(e -> switchAiModel());
        MenuItem stream = new MenuItem("Stream(Beta)の切り替え");
        stream.setOnAction(e -> switchBetaModel());
        MenuItem toggleBetaItem = new MenuItem("Beta版を有効/無効にする");
        toggleBetaItem.setOnAction(e -> toggleBeta());
        MenuItem createapi = new MenuItem("Tokenを発行");
        createapi.setOnAction(e -> createApiToken());
        MenuItem checkUpdateItem = new MenuItem("更新を確認");
        checkUpdateItem.setOnAction(e -> checkForUpdates());
        MenuItem versionItem = new MenuItem("現在のバージョン " + ver);
        versionItem.setOnAction(e -> showVersion());
        MenuItem exitItem = new MenuItem("終了");
        exitItem.setOnAction(e -> System.exit(0));

        settingsMenu.getItems().addAll(
                aimodel,
                stream,
                new SeparatorMenuItem(), // セパレータを追加
                toggleBetaItem,
                createapi,
                new SeparatorMenuItem(), // セパレータを追加
                checkUpdateItem,
                versionItem,
                new SeparatorMenuItem(), // セパレータを追加
                exitItem
        );

        // ヘルプメニュー
        Menu helpMenu = new Menu("ヘルプ");
        MenuItem helpItem = new MenuItem("使い方");
        helpItem.setOnAction(e -> showHelp());
        helpMenu.getItems().add(helpItem);

        menuBar.getMenus().addAll(viewMenu, settingsMenu, helpMenu);
        return menuBar;
    }

    // メインコンテンツ領域を作成するメソッド
    private VBox createMainContentArea() {
        betaStatusLabel = new Label("Beta版: " + (isBetaEnabled ? "有効" : "無効"));
        Label readLabel = new Label("Beta版の有効/無効は設定から変更できます");
        Label descriptionLabel = new Label("エネルギー使用状況と太陽光発電のデータを入力してください。");

        // パネル数設定
        Label panelLabel = new Label("太陽光パネルの数を入力してください（1〜30）：");
        panelScale = new Slider(1, 30, 1);
        panelScale.setShowTickLabels(true);
        panelScale.setShowTickMarks(true);
        panelScale.setMajorTickUnit(5);
        panelScale.setBlockIncrement(1);
        TextField panelCountField = new TextField();
        panelCountField.textProperty().bindBidirectional(panelScale.valueProperty(), new javafx.util.converter.NumberStringConverter());

        // 日照時間設定
        Label sunshineLabel = new Label("日照時間を入力してください（0.5〜24時間）：");
        sunshineScale = new Slider(0.5, 24, 1);
        sunshineScale.setShowTickLabels(true);
        sunshineScale.setShowTickMarks(true);
        sunshineScale.setMajorTickUnit(2);
        sunshineScale.setBlockIncrement(0.5);
        TextField sunshineTimeField = new TextField();
        sunshineTimeField.textProperty().bindBidirectional(sunshineScale.valueProperty(), new javafx.util.converter.NumberStringConverter());

        // 1日の総発電量
        generationField = createTextFieldWithLabel("1日の総発電量 (kWh) を入力してください：");
        locationComboBox = createComboBoxWithLabel("お住まいの地域を選択してください：",
                "北海道", "青森県", "岩手県", "宮城県", "秋田県", "山形県", "福島県", "茨城県", "栃木県", "群馬県", "埼玉県", "千葉県", "東京都",
                "神奈川県", "新潟県", "富山県", "石川県", "福井県", "山梨県", "長野県", "岐阜県", "静岡県", "愛知県", "三重県", "滋賀県",
                "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県", "鳥取県", "島根県", "岡山県", "広島県", "山口県", "徳島県", "香川県",
                "愛媛県", "高知県", "福岡県", "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", "鹿児島県", "沖縄県");

        // 設置角度
        angleScale = createSliderWithLabel("設置角度を入力してください（0〜180°）：", 0, 180, 0);
        angleScale.setShowTickLabels(true);
        angleScale.setShowTickMarks(true);
        angleScale.setMajorTickUnit(30);
        angleScale.setBlockIncrement(5);
        TextField angleField = new TextField();
        angleField.textProperty().bindBidirectional(angleScale.valueProperty(), new javafx.util.converter.NumberStringConverter());
        
        // 設置年
        installationTimeField = createTextFieldWithLabel("太陽光発電システムを設置した年を入力してください（例：1990）：");

        // システム容量
        systemCapacityField = createTextFieldWithLabel("太陽光発電システム全体の容量 (kW) を入力してください：");

        // アドバイスを求める目的
        purposeField = createTextAreaWithLabel("アドバイスを求める具体的な目的を簡潔に入力してください（例: 発電量を増やしたい）：");
        purposeField.setPrefRowCount(3);

        Label aiRead = new Label("BETA版が有効の場合にはAIがアドバイスを生成します。ただし少し時間が掛かるよ！");
        progressBar = new ProgressBar();
        progressBar.setVisible(false);

        analyzeButton = new Button("実行");
        analyzeButton.setOnAction(e -> onAnalyzeButtonClick());

        webView = new WebView();
        webEngine = webView.getEngine();

        // レイアウト
        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);
        inputGrid.setPadding(new Insets(10));
        inputGrid.addRow(0, betaStatusLabel, readLabel);
        inputGrid.addRow(1, descriptionLabel);
        inputGrid.addRow(2, panelLabel, panelCountField);
        inputGrid.addRow(3, sunshineLabel, sunshineTimeField);
        inputGrid.addRow(4, generationField);
        inputGrid.addRow(5, locationComboBox);
        inputGrid.addRow(6,  angleField);
        inputGrid.addRow(7, installationTimeField);
        inputGrid.addRow(8, systemCapacityField);
        inputGrid.addRow(9, purposeField);
        inputGrid.addRow(10, aiRead);

        // inputGrid内の要素を左寄せに設定
        inputGrid.getChildren().forEach(node -> GridPane.setHalignment(node, javafx.geometry.HPos.LEFT));

        HBox buttonBox = new HBox(10);
        buttonBox.setAlignment(Pos.CENTER);
        buttonBox.getChildren().add(analyzeButton);

        VBox root = new VBox(15);
        root.setPadding(new Insets(20));
        root.getChildren().addAll(inputGrid, buttonBox, progressBar, webView);
        VBox.setVgrow(webView, Priority.ALWAYS);

        // Beta版コンポーネントの追加/削除
        if (isBetaEnabled) {
            addBetaComponents(inputGrid);
        } else {
            removeBetaComponents(inputGrid);
        }

        return root;
    }

    // TextFieldとLabelを組み合わせたUI要素を作成するメソッド
    private TextField createTextFieldWithLabel(String labelText) {
        Label label = new Label(labelText);
        TextField textField = new TextField();
        HBox hbox = new HBox(10);
        hbox.getChildren().addAll(label, textField);
        return textField;
    }
    
    // ComboBoxとLabelを組み合わせたUI要素を作成するメソッド
    private ComboBox<String> createComboBoxWithLabel(String labelText, String... items) {
        Label label = new Label(labelText);
        ComboBox<String> comboBox = new ComboBox<>();
        comboBox.getItems().addAll(items);
        HBox hbox = new HBox(10);
        hbox.getChildren().addAll(label, comboBox);
        return comboBox;
    }

    // SliderとLabelを組み合わせたUI要素を作成するメソッド
    private Slider createSliderWithLabel(String labelText, double min, double max, double value) {
        Label label = new Label(labelText);
        Slider slider = new Slider(min, max, value);
        HBox hbox = new HBox(10);
        hbox.getChildren().addAll(label, slider);
        return slider;
    }

    // TextAreaとLabelを組み合わせたUI要素を作成するメソッド
    private TextArea createTextAreaWithLabel(String labelText) {
        Label label = new Label(labelText);
        TextArea textArea = new TextArea();
        HBox hbox = new HBox(10);
        hbox.getChildren().addAll(label, textArea);
        return textArea;
    }
    
    // Beta版機能のUIコンポーネントを追加するメソッド
    private void addBetaComponents(GridPane gridPane) {
    	if (!gridPane.getChildren().contains(generationField)) {
            gridPane.getChildren().add(generationField);
        }
        gridPane.getChildren().addAll(
                generationField,
                locationComboBox,
                angleScale,
                installationTimeField,
                systemCapacityField,
                purposeField
        );
    }

    // Beta版機能のUIコンポーネントを削除するメソッド
    private void removeBetaComponents(GridPane gridPane) {
    	if (!gridPane.getChildren().contains(generationField)) {
            gridPane.getChildren().add(generationField);
        }
        gridPane.getChildren().removeAll(
                generationField,
                locationComboBox,
                angleScale,
                installationTimeField,
                systemCapacityField,
                purposeField
        );
    }

    // Beta版の有効/無効を切り替えるメソッド
    private void toggleBeta() {
        isBetaEnabled = !isBetaEnabled;
        betaStatusLabel.setText("Beta版: " + (isBetaEnabled ? "有効" : "無効"));

        if (isBetaEnabled) {
            addBetaComponents((GridPane) betaStatusLabel.getParent());
            showInfoDialog("変更", "Betaモードを「有効」に切り替えました");
        } else {
            removeBetaComponents((GridPane) betaStatusLabel.getParent());
            showInfoDialog("変更", "Betaモードを「無効」に切り替えました");
        }

        saveSettings();
    }

    // アプリケーションのバージョンを表示するメソッド
    private void showVersion() {
        showInfoDialog("バージョン情報",
                "バージョン: " + ver + "\n" +
                        "①. 新しくストリーミング処理を行う機能を追加。\n" +
                        "②. ただ実験機能だから機能しないときがある。\n" +
                        "以上 Version " + ver + " の更新履歴です");
    }

    // ヘルプ情報を表示するメソッド
    private void showHelp() {
        showInfoDialog("ヘルプ",
                "エネルギー効率改善アドバイザーの使い方:\n" +
                        "1. 太陽光パネルの数をスライダーで指定します（最大30）。\n" +
                        "2. 日照時間をスライダーで指定します（最大24時間）。\n" +
                        "3. '実行'ボタンをクリックします。\n" +
                        "4. AIがアドバイスを生成し、テキストボックスに表示します。\n" +
                        "5. AIは自作のWEB APIです。\n" +
                        "6. 自動更新機能でアプデが楽になります。\n" +
                        "注意: Beta版が有効の場合、AIがより詳細なアドバイスを提供します");
    }

    // 設定を読み込むメソッド
    private void loadSettings() {
        File settingsFile = new File("settings.json");
        if (settingsFile.exists()) {
            try (BufferedReader reader = new BufferedReader(new FileReader(settingsFile))) {
                StringBuilder jsonContent = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    jsonContent.append(line).append("\n");
                }

                Gson gson = new Gson();
                Type type = new TypeToken<Map<String, String>>() {}.getType();
                Map<String, String> settingsMap = gson.fromJson(jsonContent.toString(), type);

                isBetaEnabled = Boolean.parseBoolean(settingsMap.getOrDefault("is_beta_enabled", "false"));
                apiUrl = settingsMap.getOrDefault("api_url", "Gemini");
                apiToken = settingsMap.getOrDefault("api_token", "");
                UseDiv = settingsMap.getOrDefault("usediv", "False");

            } catch (IOException e) {
                e.printStackTrace();
                showErrorDialog("エラー", "設定の読み込み中にエラーが発生しました。");
            }
        }
    }

    // 設定を保存するメソッド
    private void saveSettings() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("settings.json"))) {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            String settingsJson = gson.toJson(Map.of(
                    "is_beta_enabled", isBetaEnabled,
                    "api_url", apiUrl,
                    "api_token", apiToken,
                    "usediv", UseDiv
            ));
            writer.write(settingsJson);
        } catch (IOException e) {
            e.printStackTrace();
            showErrorDialog("エラー", "設定の保存中にエラーが発生しました。");
        }
    }

    // AIモデルを切り替えるメソッド
    private void switchAiModel() {
        apiUrl = apiUrl.equals("Gemini") ? "OpenAI" : "Gemini";
        showInfoDialog("変更", apiUrl + "モデルに切り替えました");
        saveSettings();
    }

    // ストリーミング処理の有効/無効を切り替えるメソッド
    private void switchBetaModel() {
        UseDiv = UseDiv.equals("False") ? "True" : "False";
        showInfoDialog("変更", "ストリーミング処理を" + (UseDiv.equals("True") ? "有効" : "無効") + "に切り替えました");
        saveSettings();
    }

    // APIトークンを生成するメソッド
    private void createApiToken() {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle("APIトークン");
        dialog.setHeaderText("APIトークンを入力してください");
        dialog.setContentText("トークン:");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(token -> {
            apiToken = token;
            saveSettings();
            showInfoDialog("APIトークン", "APIトークンが保存されました: " + apiToken);
        });
    }

    // アプリケーションの更新を確認するメソッド
    public void checkForUpdates() {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                String versionUrl = "https://gamelist1990.github.io/gamelist1990/version/appver.json";
                URI uri = new URI(versionUrl);
                URL url = uri.toURL();
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod("GET");
                BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                StringBuilder result = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    result.append(line);
                }
                reader.close();

                Gson gson = new Gson();
                Type type = new TypeToken<Map<String, String>>() {}.getType();
                Map<String, String> versionMap = gson.fromJson(result.toString(), type);
                String currentVersion = ver;
                for (String version : versionMap.keySet()) {
                    if (Float.parseFloat(version) > Float.parseFloat(currentVersion)) {
                        Platform.runLater(() -> {
                            Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
                            alert.setTitle("更新の確認");
                            alert.setHeaderText("新しいバージョン " + version + " が利用可能です。更新しますか？");
                            alert.setContentText("はい / いいえ");

                            ButtonType buttonTypeYes = new ButtonType("はい");
                            ButtonType buttonTypeNo = new ButtonType("いいえ");

                            alert.getButtonTypes().setAll(buttonTypeYes, buttonTypeNo);

                            alert.showAndWait().ifPresent(response -> {
                                if (response == buttonTypeYes) {
                                    downloadAndUpdate(versionMap.get(version), version);
                                } else {
                                    showInfoDialog("更新", "最新バージョン " + currentVersion + " を使用しています");
                                }
                            });
                        });
                        break;
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
                showErrorDialog("エラー", "更新の確認中にエラーが発生しました。");
            }
        });
        executor.shutdown();
    }

    // アプリケーションをダウンロードして更新するメソッド
    private void downloadAndUpdate(String downloadUrl, String version) {
        // ダウンロード状況を表示するステージを作成
        Stage downloadStage = new Stage();
        downloadStage.initStyle(StageStyle.UTILITY);
        downloadStage.initModality(Modality.APPLICATION_MODAL);
        downloadStage.setResizable(false);

        ProgressBar progressBar = new ProgressBar(0);
        progressBar.setPrefWidth(300);

        Label statusLabel = new Label("ダウンロード中...");

        VBox root = new VBox(10, statusLabel, progressBar);
        root.setAlignment(Pos.CENTER);
        root.setPadding(new Insets(20));

        Scene scene = new Scene(root);
        downloadStage.setScene(scene);
        downloadStage.show();

        // メインウィンドウを無効化
        analyzeButton.setDisable(true);

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                Path downloadFolder = Paths.get(System.getProperty("user.home"), "Downloads");
                Path targetPath = downloadFolder.resolve("setup.exe");

                try (InputStream in = new URI(downloadUrl).toURL().openStream()) {
                    long fileSize = in.available();
                    long downloaded = 0;

                    Files.copy(in, targetPath, StandardCopyOption.REPLACE_EXISTING);

                    while (downloaded < fileSize) {
                        downloaded += in.transferTo(Files.newOutputStream(targetPath));
                        double progress = (double) downloaded / fileSize;
                        Platform.runLater(() -> progressBar.setProgress(progress));
                    }
                }

                Platform.runLater(() -> {
                    downloadStage.close();
                    showInfoDialog("更新", "インストールが完了しました。: インストールした ver." + version + " の setup.exe を起動します");

                    // 2秒間の待機処理
                    PauseTransition delay = new PauseTransition(Duration.seconds(2));
                    delay.setOnFinished(event -> {
                        try {
                            Desktop.getDesktop().open(targetPath.toFile());
                            System.exit(0);
                        } catch (IOException e) {
                            e.printStackTrace();
                            showErrorDialog("エラー", "setup.exe を開けませんでした。");
                        }
                    });
                    delay.play();
                });
            } catch (Exception e) {
                e.printStackTrace();
                Platform.runLater(() -> {
                    downloadStage.close();
                    showErrorDialog("エラー", "ダウンロード中にエラーが発生しました。");
                    analyzeButton.setDisable(false);
                });
            }
        });
        executor.shutdown();
    }

    // ユーザーに更新を促すメソッド
    public void userChoiceToUpdate() {
        String versionUrl = "https://gamelist1990.github.io/gamelist1990/version/appver.json";
        try {
            URI uri = new URI(versionUrl);
            URL url = uri.toURL();
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuilder result = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                result.append(line);
            }
            reader.close();

            Gson gson = new Gson();
            Type type = new TypeToken<Map<String, String>>() {}.getType();
            Map<String, String> versionMap = gson.fromJson(result.toString(), type);
            String currentVersion = ver;
            for (String version : versionMap.keySet()) {
                if (Float.parseFloat(version) > Float.parseFloat(currentVersion)) {
                    Platform.runLater(() -> {
                        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
                        alert.setTitle("更新の確認");
                        alert.setHeaderText("新しいバージョン " + version + " が利用可能です。更新しますか？");
                        alert.setContentText("はい / いいえ");

                        ButtonType buttonTypeYes = new ButtonType("はい");
                        ButtonType buttonTypeNo = new ButtonType("いいえ");

                        alert.getButtonTypes().setAll(buttonTypeYes, buttonTypeNo);

                        alert.showAndWait().ifPresent(response -> {
                            if (response == buttonTypeYes) {
                                downloadAndUpdate(versionMap.get(version), version);
                            } else {
                                showInfoDialog("更新", "更新した方が良いよ...");
                            }
                        });
                    });
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            showErrorDialog("エラー", "更新の確認中にエラーが発生しました。");
        }
    }

    // 分析ボタンクリック時の処理
    private void onAnalyzeButtonClick() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastClickTime < 5000) {
            long waitTime = 3 - ((currentTime - lastClickTime) / 1000);
            showErrorDialog("ClickError", "再度クリックできるまで後 " + waitTime + " 秒お待ちください");
            return;
        }
        lastClickTime = currentTime;

        analyzeButton.setDisable(true);
        progressBar.setVisible(true);
        Platform.runLater(() -> webEngine.loadContent("<p>ユーザーの回答を処理しています...</p>"));

        int panelCount = (int) panelScale.getValue();
        int sunshineTime = (int) sunshineScale.getValue();
        String generation = generationField.getText();
        String selectedPrefecture = locationComboBox.getValue();
        int angle = (int) angleScale.getValue();
        String installationYearText = installationTimeField.getText();
        String systemCapacity = systemCapacityField.getText();
        String purpose = purposeField.getText();

        new Thread(() -> {
            try {
                if (UseDiv.equals("True")) {
                    getAdviceFromAI_stream(panelCount, sunshineTime, generation, selectedPrefecture, angle,
                            installationYearText, systemCapacity, purpose, webEngine);
                } else {
                    String aiResponse = calculateSolarPower(panelCount, sunshineTime, generation, selectedPrefecture,
                            angle, installationYearText, systemCapacity, purpose);
                    String html = markdownToHtml(aiResponse);
                    Platform.runLater(() -> webEngine.loadContent(html));
                }
            } catch (Exception e) {
                System.out.println(e.getMessage());
                showErrorDialog("エラー", "アドバイスの生成中にエラーが発生しました。");
            } finally {
                progressBar.setVisible(false);
                analyzeButton.setDisable(false);
            }
        }).start();
    }

    // 太陽光発電量を計算し、基本的なアドバイスを提供するメソッド
    private String calculateSolarPower(int panelCount, int sunshineTime, String generation, String selectedPrefecture,
            int angle, String installationYearText, String systemCapacity, String purpose) throws Exception {
        double powerPerPanel = 0.2; // kW
        double solarPower = panelCount * sunshineTime * powerPerPanel;
        String adviceText = "";

        if (solarPower < 1) {
            adviceText = "<p>現在の発電量は<b>1kWh以下</b>となっています。パネルの数や日照時間を増やすことで、発電量を増やすことが可能です。参考になる資料として、<a href='https://www.enecho.meti.go.jp/category/saving_and_new/saiene/renewable/solar/index.html'>資源エネルギー庁の太陽光発電ガイド</a>をご覧ください。</p>";
        } else if (solarPower < 5) {
            adviceText = "<p>現在の発電量は<b>5kWh以下</b>となっています。発電量をさらに向上させるためには、パネルの角度や設置場所を見直すことをお勧めします。参考になる資料として、<a href='https://www.enecho.meti.go.jp/category/saving_and_new/saiene/renewable/solar/index.html'>資源エネルギー庁の太陽光発電ガイド</a>をご覧ください。</p>";
        } else {
            adviceText = "<p>素晴らしい！あなたの太陽光発電システムは非常に効率的に動作しています。さらなる効率化のための情報は、<a href='https://www.enecho.meti.go.jp/category/saving_and_new/saiene/renewable/solar/index.html'>資源エネルギー庁の太陽光発電ガイド</a>をご覧ください。</p>";
        }

        if (isBetaEnabled) {
            return getAdviceFromAI_streamPost(panelCount, sunshineTime, generation, selectedPrefecture, angle,
                    installationYearText, systemCapacity, purpose);
        } else {
            return "<p>あなたの太陽光発電システムは、1日あたり約<b>" + solarPower
                    + "kWh</b>の電力を生成します。</p>" + adviceText
                    + "<p>もし詳細な情報を知りたい場合にはBeta版を有効にしてみてください。現時点2024/5/28の段階ではまだ未完成です</p>";
        }
    }

    // AIからアドバイスを取得するメソッド (ストリーミング処理なし)
    private String getAdviceFromAI(int panelCount, int sunshineTime, String generation, String selectedPrefecture,
            int angle, String installationYearText, String systemCapacity, String purpose) throws Exception {
        String question = "質問内容は以下通りです:太陽光発電のデータが次のような場合、どのようなアドバイスがありますか？ パネル数: "
                + panelCount + ", 日照時間: " + sunshineTime + "時間, 1日の総発電量(kWh): " + generation + ", どこに住んでいるか: "
                + selectedPrefecture + ", ソーラーパネルの設置角度: " + angle + "°, 設置した年(現在の日付は" + currentYear
                + "年です):" + installationYearText + ", 太陽光発電システム全体の容量(kW): " + systemCapacity + ", アドバイスを求める目的: "
                + purpose + "。回答形式：以下の形式に沿ってください<h1>太陽光発電システムのデータ分析とアドバイス</h1><br>" + //
                        "<h2>データ:</h2>" + "<ul>" + "<li>パネル数: </li>" + "<li>日照時間: </li>" + "<li>1日の総発電量: </li>"
                        + "<li>設置場所: </li>" + "<li>パネル設置角度: </li>" + "<li>設置年: </li>"
                        + "<li>システム容量: </li>" + "</ul>" + "<h2>アドバイス:</h2>"
                        + "というような形式でマークダウン形式で出力,セキュリティ関係上これだけしか情報が提供できませんご了承ください";
        int userID = user_id;
        String userid = "&user_id=" + userID;
        String token = apiToken;
        String NToken = "&token=" + token;
        String para = "?";
        String prompt = "&prompt=";
        String encodedQuestion = URLEncoder.encode(question, StandardCharsets.UTF_8.toString());
        URI uri = new URI(MainAPIurl + para + apiUrl + prompt + encodedQuestion + userid + NToken);
        System.out.println(MainAPIurl + para + apiUrl + prompt + encodedQuestion + userid + NToken);

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder().uri(uri).header("Content-Type", "application/json")
                .header("User-Agent",
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3")
                .GET().build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

            System.out.println(response);

            // JSONオブジェクトとしてレスポンスを解析します。
            Gson gson = new Gson();
            Type type = new TypeToken<Map<String, String>>() {}.getType();
            Map<String, String> responseMap = gson.fromJson(response.body(), type);

            // "response"フィールドが存在するかどうかを確認します。
            if (responseMap.containsKey("response")) {
                // 存在する場合はその値を使用します。
                return responseMap.get("response");
            } else {
                // 存在しない場合はデフォルトのメッセージを使用します。
                return "AIの回答に問題が起きています,";
            }
        } catch (Exception e) {
            // エラーメッセージをログに記録または表示します。
            System.err.println("エラーが発生しました: " + e.getMessage());
            // エラーが発生した場合は適切なメッセージを
            return "サーバーからのレスポンスを受け取る際にエラーが発生しました<br>(同じ値での送信をした場合に400エラーが返されますそれ以外にはServer側のAIに異常が起きてエラーになっている可能性があります)<br>追記：Version0.6から発生しているエラーでhttps;//webapi-8trs.onrender.comというのがあるのですが原因不明な為解決に時間を要する可能性があります(現段階では字数制限かも)<br>エラー内容："
            + e.getMessage() + ".";
}
}

// AIからアドバイスを取得するメソッド (ストリーミング処理あり)
private void getAdviceFromAI_stream(int panelCount, int sunshineTime, String generation, String selectedPrefecture,
    int angle, String installationYearText, String systemCapacity, String purpose, WebEngine webEngine)
    throws Exception {
// HTTPリクエストを作成します。
String question = "質問内容は以下通りです:太陽光発電のデータが次のような場合、どのようなアドバイスがありますか？ パネル数: "
        + panelCount + ", 日照時間: " + sunshineTime + "時間, 1日の総発電量(kWh): " + generation + ", どこに住んでいるか: "
        + selectedPrefecture + ", ソーラーパネルの設置角度: " + angle + "°, 設置した年(現在の日付は" + currentYear
        + "年です):" + installationYearText + ", 太陽光発電システム全体の容量(kW): " + systemCapacity + ", アドバイスを求める目的: "
        + purpose + "。回答形式：以下の形式に沿ってください<h1>太陽光発電システムのデータ分析とアドバイス</h1><br>" + //
                "<h2>データ:</h2>" + "<ul>" + "<li>パネル数: </li>" + "<li>日照時間: </li>" + "<li>1日の総発電量: </li>"
                + "<li>設置場所: </li>" + "<li>パネル設置角度: </li>" + "<li>設置年: </li>"
                + "<li>システム容量: </li>" + "</ul>" + "<h2>アドバイス:</h2>"
                + "というような形式でマークダウン形式で出力,セキュリティ関係上これだけしか情報が提供できませんご了承ください";
URL url = new URL("https://webapi-8trs.onrender.com/stream"); // ストリーミングレスポンスをサポートするURLに変更します。
HttpURLConnection connection = (HttpURLConnection) url.openConnection();

// Set up the connection
connection.setRequestMethod("POST");
connection.setDoOutput(true);
connection.setRequestProperty("Content-Type", "application/json; utf-8");

// Define parameters
String provider = apiUrl;
String system = "";
String token = apiToken;
Platform.runLater(() -> webEngine.loadContent(""));

// Create JSON string
String jsonInputString = String.format(
        "{\"provider\": \"%s\", \"prompt\": \"%s\", \"system\": \"%s\", \"token\": \"%s\"}", provider, question,
        system, token);

// Send POST request
try (OutputStream os = connection.getOutputStream()) {
    byte[] input = jsonInputString.getBytes(StandardCharsets.UTF_8);
    os.write(input, 0, input.length);
}

try {
    // Now read the SSE
    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String line;
    while ((line = reader.readLine()) != null) {
        try {
            if (line.startsWith("data: ")) {
                String jsonString = line.substring(6); // Remove "data: "
                // System.out.println(jsonString);
                JSONObject jsonObject = new JSONObject(jsonString);
                String responseValue = jsonObject.getString("response");

                // MarkdownをHTMLに変換します。
                System.out.println(responseValue);

                String html = markdownToHtml(responseValue);

                String script = "document.body.innerHTML += '" + StringEscapeUtils.escapeEcmaScript(html)
                        + "';";
                Platform.runLater(() -> webEngine.executeScript(script));
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("エラーが発生しました: " + e.getMessage());
        }
    }
    reader.close();
} catch (IOException e) {
    e.printStackTrace();
}
}

// AIからアドバイスを取得するメソッド (ストリーミング処理あり、POSTリクエストを使用)
private String getAdviceFromAI_streamPost(int panelCount, int sunshineTime, String generation,
    String selectedPrefecture, int angle, String installationYearText, String systemCapacity, String purpose)
    throws Exception {
// HTTPリクエストを作成します。
String question = "質問内容は以下通りです:太陽光発電のデータが次のような場合、どのようなアドバイスがありますか？ パネル数: "
        + panelCount + ", 日照時間: " + sunshineTime + "時間, 1日の総発電量(kWh): " + generation + ", どこに住んでいるか: "
        + selectedPrefecture + ", ソーラーパネルの設置角度: " + angle + "°, 設置した年(現在の日付は" + currentYear
        + "年です):" + installationYearText + ", 太陽光発電システム全体の容量(kW): " + systemCapacity + ", アドバイスを求める目的: "
        + purpose + "。回答形式：以下の形式に沿ってください## 太陽光発電システムのデータ分析とアドバイス\n" + //
                "<h2>データ:</h2>" + "<ul>" + "<li>パネル数: </li>" + "<li>日照時間: </li>" + "<li>1日の総発電量: </li>"
                + "<li>設置場所: </li>" + "<li>パネル設置角度: </li>" + "<li>設置年: </li>"
                + "<li>システム容量: </li>" + "</ul>" + "<h2>アドバイス:</h2>"
                + "というような形式でマークダウン形式で出力,セキュリティ関係上これだけしか情報が提供できませんご了承ください";
URI uri = new URI(MainAPIurl);
Map<String, String> jsonMap = new HashMap<>();
jsonMap.put("prompt", question);
jsonMap.put("provider", apiUrl);
jsonMap.put("system", "");
jsonMap.put("token", apiToken);
String json = new Gson().toJson(jsonMap);

HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder().uri(uri).POST(HttpRequest.BodyPublishers.ofString(json))
        .header("Content-Type", "application/json").build();

HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

// レスポンスヘッダーを取得します。
HttpHeaders headers = response.headers();
headers.map().forEach((k, v) -> System.out.println(k + ":" + v));

// レスポンスボディを取得します。
String responseBody = response.body();
System.out.println(responseBody);

// Gsonを使用してレスポンスボディをJavaオブジェクトに変換します。
Gson gson = new Gson();
Type type = new TypeToken<Map<String, String>>() {}.getType();
Map<String, String> myMap = gson.fromJson(responseBody, type);

// "response"の値を取得します。
String responseValue = myMap.get("response");

// MarkdownをHTMLに変換します。
String html = markdownToHtml(responseValue);

return html;
}

// MarkdownをHTMLに変換するメソッド
public static String markdownToHtml(String markdown) {
// ヘッダーを変換
markdown = convertHeaders(markdown);

// 強調、取り消し線、上付き文字、下付き文字を変換
markdown = convertEmphasis(markdown);

// リストを変換
markdown = convertLists(markdown);

// 引用ブロックを変換
markdown = convertBlockquotes(markdown);

// コードブロックを変換
markdown = convertCodeBlocks(markdown);

// 水平線を変換
markdown = convertHorizontalRules(markdown);

// テーブルを変換
markdown = convertTables(markdown);

// リンクと画像を変換
markdown = convertLinksAndImages(markdown);

// 改行
markdown = convertNewlines(markdown);

// チェックボックス
markdown = convertCheckboxes(markdown);

return markdown;
}

// ヘッダーの変換
private static String convertHeaders(String markdown) {
Pattern headerPattern = Pattern.compile("^(#{1,6})(.*?)$", Pattern.MULTILINE);
Matcher headerMatcher = headerPattern.matcher(markdown);
while (headerMatcher.find()) {
    int level = headerMatcher.group(1).length();
    markdown = markdown.replace(headerMatcher.group(),
            "<h" + level + ">" + headerMatcher.group(2).trim() + "</h" + level + ">");
}
return markdown;
}

// 強調、取り消し線、上付き文字、下付き文字の変換
private static String convertEmphasis(String markdown) {
markdown = markdown.replaceAll("(\\*\\*|__)(.*?)\\1", "<strong>$2</strong>");
markdown = markdown.replaceAll("(\\*|_)(.*?)\\1", "<em>$2</em>");
markdown = markdown.replaceAll("~~(.*?)~~", "<del>$1</del>");
markdown = markdown.replaceAll("\\^(.*?)\\^", "<sup>$1</sup>");
markdown = markdown.replaceAll(",,(.*?),,", "<sub>$1</sub>");
markdown = markdown.replaceAll("\\*(\\S+)\\*", "<em>$1</em>");
return markdown;
}

// 改行の変換
private static String convertNewlines(String markdown) {
// 改行を<br>タグに変換
markdown = markdown.replaceAll("(\\r?\\n)", "<br>");

return markdown;
}

// リストの変換
private static String convertLists(String markdown) {
markdown = markdown.replaceAll("^\\d+\\.\\s", "<li>");
markdown = markdown.replaceAll("^\\[\\s*(x| )\\]\\s", "<li><input type=\"checkbox\"$1 checked>");
markdown = markdown.replaceAll("^[-*+]\\s", "<li>");
markdown = markdown.replaceAll("<li>", "<ul><li>");
markdown = markdown.replaceAll("<li>\\s*\\<\\/ul\\>", "</ul></li>");
markdown = markdown.replaceAll("<li>", "<ol><li>");
markdown = markdown.replaceAll("<li>\\s*\\<\\/ol\\>", "</ol></li>");
return markdown;
}

// 引用ブロックの変換
private static String convertBlockquotes(String markdown) {
Pattern blockquotePattern = Pattern.compile("^>(.*?)$", Pattern.MULTILINE);
Matcher blockquoteMatcher = blockquotePattern.matcher(markdown);
while (blockquoteMatcher.find()) {
    markdown = markdown.replace(blockquoteMatcher.group(),
            "<blockquote>" + blockquoteMatcher.group(1).trim() + "</blockquote>");
}
return markdown;
}

// コードブロックの変換
private static String convertCodeBlocks(String markdown) {
Pattern codeBlockPattern = Pattern.compile("```(.*?)```", Pattern.DOTALL);
Matcher codeBlockMatcher = codeBlockPattern.matcher(markdown);
while (codeBlockMatcher.find()) {
    markdown = markdown.replace(codeBlockMatcher.group(),
            "<pre><code>" + codeBlockMatcher.group(1).trim() + "</code></pre>");
}
return markdown;
}

// チェックボックスの変換
private static String convertCheckboxes(String markdown) {
Pattern checkboxPattern = Pattern.compile("\\[([x| ])] (.*?)$", Pattern.MULTILINE);
Matcher checkboxMatcher = checkboxPattern.matcher(markdown);
while (checkboxMatcher.find()) {
    String checked = checkboxMatcher.group(1).equals("x") ? " checked" : "";
    markdown = markdown.replace(checkboxMatcher.group(),
            "<input type=\"checkbox\"" + checked + " disabled> " + checkboxMatcher.group(2));
}
return markdown;
}

// 水平線の変換
private static String convertHorizontalRules(String markdown) {
markdown = markdown.replaceAll("^(?:[-*_]{3,})\\s*$", "<hr>");
return markdown;
}

// テーブルの変換
private static String convertTables(String markdown) {
Pattern tablePattern = Pattern.compile("^\\|(.*)\\|\\n(\\|[-:]+\\|\\n)((\\|.*\\|\\n)*)",
        Pattern.MULTILINE);
Matcher tableMatcher = tablePattern.matcher(markdown);
while (tableMatcher.find()) {
    String tableHeader = tableMatcher.group(1).trim();
    String tableBody = tableMatcher.group(3).trim();
    String htmlTable = "<table><thead><tr><th>" + tableHeader.replace("|", "</th><th>")
            + "</th></tr></thead><tbody><tr><td>"
            + tableBody.replace("|", "</td><td>").replace("\n", "</td></tr><tr><td>")
            + "</td></tr></tbody></table>";
    markdown = markdown.replace(tableMatcher.group(), htmlTable);
}
return markdown;
}

// リンクと画像を変換
private static String convertLinksAndImages(String markdown) {
markdown = markdown.replaceAll("\\[(.*?)\\]\\((.*?)\\)", "<a href=\"$2\">$1</a>");
markdown = markdown.replaceAll("\\!\\[(.*?)\\]\\((.*?)\\)", "<img src=\"$2\" alt=\"$1\">");
return markdown;
}

// 情報ダイアログを表示するメソッド
private void showInfoDialog(String title, String message) {
Platform.runLater(() -> {
    Alert alert = new Alert(AlertType.INFORMATION);
    alert.setTitle(title);
    alert.setHeaderText(null);
    alert.setContentText(message);
    alert.showAndWait();
});
}

// エラーダイアログを表示するメソッド
private void showErrorDialog(String title, String message) {
Platform.runLater(() -> {
    Alert alert = new Alert(Alert.AlertType.ERROR);
    alert.setTitle(title);
    alert.setHeaderText(null);
    alert.setContentText(message);
    alert.showAndWait();
});
}

// アプリケーションのメインメソッド
public static void main(String[] args) {
launch(args);
}
}
            